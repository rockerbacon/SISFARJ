package database;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.lang.reflect.Field;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class Mapper {
	
	private Connection connection;
	
	/**
	 * Inicializa um mapper para a conexao especificada
	 * @param connection: Conexao utilizada pelo mapper
	 */
	public Mapper (Connection connection) {
		this.connection = connection;
	}
	
	/**
	 * 
	 * Interface que permite compatibilidade com funcoes de mapeamento
	 *
	 */
	public static interface ObjectFactory {
		/**
		 * 
		 * @return: Lista com nomes de todas as tabelas que armazenem as informacoes contidas no objeto
		 */
		public List<String> getTableDependancies ();
		/**
		 * 
		 * @return: Nova instancia de objeto a ser mapeado
		 */
		public Object newInstance();
	}
	
	/**
	 * 
	 * Interface para implementacao de funcoes de filtro
	 *
	 */
	public static class Filter {
		private String paramFilter;
		private Object paramValue;
		/**
		 * 
		 * @param attr: Nome do atributo do objeto a ser filtrado
		 * @param sqlOp: Operador sql usado na comparacao dos valores
		 * @param value: Valor utilizado para comparar com atributo
		 * 
		 */
		public Filter (String attr, String sqlOp, Object value) {
			this.paramFilter = attr+sqlOp+"?";
			this.paramValue = value;
		}
		
		public String getParamFilter () { return this.paramFilter; }
		public Object getParamValue () { return this.paramValue; }
	}
	
	/**
	 * Gera prepared statement de acordo com os filtros
	 * @param query: string de query ja construida
	 * @param parameters: array com parametros ordenados
	 * @return
	 */
	private PreparedStatement generateQuery (String query, Object[] parameters) throws SQLException {
		PreparedStatement statement = this.connection.prepareStatement(query);
		
		for (int i = 0; i < parameters.length; i++) {
			statement.setObject(i+1, parameters[i]);
		}
		
		return statement;
	}
	
	/**
	 * @return: lista de nome de atributos em @param obj
	 */
	private static ArrayList<String> getObjectAttributes (Object obj) {
		ArrayList<String> attributes;
		Class objClass = obj.getClass();
		Field[] fields = objClass.getDeclaredFields();
		
		attributes = new ArrayList<String>(fields.length);
		for (Field f : fields) {
			attributes.add(f.getName());
		}
		
		return attributes;
		
	}

	/**
	 * 
	 * Mapeia classe de acordo com os filtros executando query no formato:
	 * 		SELECT	colum1, colum2, ..., columN
	 * 		FROM	table1 NATURAL JOIN table2 NATURAL JOIN ... tableN
	 * 		WHERE	condition1 AND condition2 AND ... conditionN
	 * @param maxRows: Numero maximo de linhas a serem trazidas, 0 indica que nao ha limite
	 * @param factory: Fabrica de objetos que instancia objetos a serem mapeados
	 * @param filter: Filtro obrigatorio
	 * @param others: Filtros opcionais 
	 * 
	 */
	public LinkedList<Object> get(int maxRows, Mapper.ObjectFactory factory, Filter filter, Filter... others) throws IllegalArgumentException, SQLException {
		
		Object prop = factory.newInstance();
		Class<?> outputClass = prop.getClass();
		ArrayList<String> attrs = Mapper.getObjectAttributes(prop);
		List<String> tables = factory.getTableDependancies();
		
		StringBuilder query = new StringBuilder();
		ArrayList<Object> params;
		PreparedStatement prepStatement;
		ResultSet queryResult;
		Iterator<String> it;
		
		LinkedList<Object> rows;
		
		if (attrs.size() == 0) {
			throw new IllegalArgumentException("object generated by factory has no attributes");
		} else if (tables.size() == 0) {
			throw new IllegalArgumentException("factory has not declared table dependancies");
		}
		
		//preencher select da query
		it = attrs.iterator();
		query.append("SELECT\t");
		query.append(it.next());
		while(it.hasNext()) {
			query.append(",\n\t\t\t");
			query.append(it.next());
		}
		
		//preencher from da query
		it = tables.iterator();
		query.append("\nFROM\t");
		query.append(it.next());
		while (it.hasNext()) {
			query.append(" NATURAL JOIN\n\t\t");
			query.append(it.next());
		}
		
		//preencher where da query e parametros
		params = new ArrayList<Object>(others.length+1);
		
		query.append("\nWHERE\t");
		query.append(filter.getParamFilter());
		
		params.add(filter.getParamValue());
		
		for (int i = 0; i < others.length; i++) {
			query.append(" AND\n\t\t");
			query.append(others[i].getParamFilter());
			
			params.add(others[i].getParamValue());
		}
		
		prepStatement = this.generateQuery(query.toString(), params.toArray());
		
		queryResult = prepStatement.executeQuery();
		rows = new LinkedList<Object>();
		
		try {
			queryResult.next();
			while (!queryResult.isAfterLast() && maxRows != 0) {
				//instanciar objeto da linha atual
				Object obj = factory.newInstance();
				for (String attr : attrs) {
					outputClass.getDeclaredField(attr).set(obj, queryResult.getObject(attr));
				}
				
				rows.add(obj);
				
				queryResult.next();
				maxRows--;
			}
		} catch (NoSuchFieldException e) {
			throw new IllegalArgumentException("atributes of object generated by factory don't match that of the query result");
		} catch (IllegalAccessException e) {
			e.printStackTrace();
		}
		
		return rows;
	}
	
}
